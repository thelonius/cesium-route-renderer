import React, { useState, useRef, useEffect } from 'react';
import * as Cesium from 'cesium';

interface RecordButtonProps {
  viewer: Cesium.Viewer | null;
  startTime?: Cesium.JulianDate;
  stopTime?: Cesium.JulianDate;
  animationSpeed?: number;
}

export default function RecordButton({ viewer, startTime, stopTime, animationSpeed = 30 }: RecordButtonProps) {
  const [isRecording, setIsRecording] = useState(false);
  const [isPreparing, setIsPreparing] = useState(false);
  const [estimatedSeconds, setEstimatedSeconds] = useState<number | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const recordedChunksRef = useRef<Blob[]>([]);
  const animationCheckIntervalRef = useRef<number | null>(null);
  const [recordedDuration, setRecordedDuration] = useState(0);

  // Load FFmpeg on mount
  useEffect(() => {
    const loadFFmpeg = async () => {
      if (ffmpegLoadedRef.current) return;

      try {
        console.log('ðŸŽ¬ Loading FFmpeg.wasm...');
        const ffmpeg = new FFmpeg();
        ffmpegRef.current = ffmpeg;

        ffmpeg.on('log', ({ message }) => {
          console.log('FFmpeg log:', message);
        });

        ffmpeg.on('progress', ({ progress }) => {
          console.log('FFmpeg progress:', progress);
          setEncodingProgress(`${Math.round(progress * 100)}%`);
        });

        // Try loading from jsdelivr CDN (more reliable than unpkg)
        console.log('ðŸ“¦ Fetching FFmpeg core files...');
        const baseURL = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd';
        
        console.log('ðŸ“¥ Loading core JavaScript...');
        const coreURL = await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript');
        console.log('ðŸ“¥ Loading WASM module...');
        const wasmURL = await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm');
        
        console.log('ðŸš€ Initializing FFmpeg...');
        await ffmpeg.load({
          coreURL,
          wasmURL,
        });

        ffmpegLoadedRef.current = true;
        setIsLoadingFFmpeg(false);
        console.log('âœ… FFmpeg loaded successfully and ready!');
      } catch (error) {
        console.error('âŒ Failed to load FFmpeg:', error);
        console.error('Error details:', error);
        setIsLoadingFFmpeg(false);
        alert('Failed to load FFmpeg. Recording will not be available. Check console for details.');
      }
    };

    // Add a small delay to ensure component is mounted
    setTimeout(loadFFmpeg, 100);
  }, []);

  // Calculate estimated recording duration
  useEffect(() => {
    if (startTime && stopTime && animationSpeed) {
      const routeDurationSeconds = Cesium.JulianDate.secondsDifference(stopTime, startTime);
      const recordingDurationSeconds = routeDurationSeconds / animationSpeed;
      // Add 2 seconds for terrain settling
      setEstimatedSeconds(Math.ceil(recordingDurationSeconds + 2));
    }
  }, [startTime, stopTime, animationSpeed]);

  const captureFrame = async (canvas: HTMLCanvasElement, viewer: Cesium.Viewer): Promise<Blob> => {
    return new Promise((resolve, reject) => {
      // Wait for the next render to complete before capturing
      const removeListener = viewer.scene.postRender.addEventListener(() => {
        removeListener();

        // Use requestAnimationFrame to ensure the frame is fully painted
        requestAnimationFrame(() => {
          canvas.toBlob(
            (blob) => {
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error('Failed to capture frame'));
              }
            },
            'image/jpeg',
            0.85 // 85% quality
          );
        });
      });
    });
  };

  const startRecording = async () => {
    if (!viewer) return;

    try {
      setIsPreparing(true);
      const canvas = viewer.scene.canvas;
      capturedFramesRef.current = [];
      setFrameCount(0);

      // Capture frames at 30 FPS using canvas.toBlob()
      const fps = 30;
      const interval = 1000 / fps;

      setIsPreparing(false);
      setIsRecording(true);
      console.log('Recording started at 30 FPS using canvas.toBlob()');

      let lastCaptureTime = Date.now();
      const captureLoop = async () => {
        if (!captureIntervalRef.current) return;

        const now = Date.now();
        const elapsed = now - lastCaptureTime;

        if (elapsed >= interval) {
          try {
            const blob = await captureFrame(canvas, viewer);
            capturedFramesRef.current.push(blob);
            setFrameCount(capturedFramesRef.current.length);
            lastCaptureTime = now;
          } catch (error) {
            console.error('Failed to capture frame:', error);
          }
        }

        captureIntervalRef.current = window.requestAnimationFrame(captureLoop);
      };

      captureIntervalRef.current = window.requestAnimationFrame(captureLoop);

      // Check if animation has completed
      if (stopTime) {
        animationCheckIntervalRef.current = window.setInterval(() => {
          if (!viewer.clock.shouldAnimate ||
              Cesium.JulianDate.compare(viewer.clock.currentTime, stopTime) >= 0) {
            console.log('Animation completed, stopping recording automatically');
            stopRecording();
          }
        }, 500); // Check every 500ms
      }
    } catch (error) {
      console.error('Failed to start recording:', error);
      setIsPreparing(false);
      alert('Failed to start recording. Please check console for details.');
    }
  };

  const stopRecording = async () => {
    if (captureIntervalRef.current) {
      window.cancelAnimationFrame(captureIntervalRef.current);
      captureIntervalRef.current = null;
    }

    if (animationCheckIntervalRef.current) {
      clearInterval(animationCheckIntervalRef.current);
      animationCheckIntervalRef.current = null;
    }

    setIsRecording(false);
    const totalFrames = capturedFramesRef.current.length;
    console.log(`Recording stopped. Captured ${totalFrames} frames`);

    if (totalFrames === 0) {
      alert('No frames captured!');
      return;
    }

    if (!ffmpegRef.current || !ffmpegLoadedRef.current) {
      alert('FFmpeg not loaded yet. Please wait and try again.');
      return;
    }

    try {
      setIsEncoding(true);
      setEncodingProgress('0%');
      console.log('Encoding video with FFmpeg.wasm...');

      const ffmpeg = ffmpegRef.current;
      const fps = 30;

      // Write all frames to FFmpeg virtual filesystem
      for (let i = 0; i < capturedFramesRef.current.length; i++) {
        const blob = capturedFramesRef.current[i];
        const filename = `frame-${String(i).padStart(6, '0')}.jpg`;
        await ffmpeg.writeFile(filename, await fetchFile(blob));

        if (i % 50 === 0) {
          console.log(`Wrote frame ${i + 1}/${totalFrames}`);
        }
      }

      console.log('All frames written, starting encoding...');

      // Run FFmpeg to create video
      await ffmpeg.exec([
        '-framerate', String(fps),
        '-i', 'frame-%06d.jpg',
        '-c:v', 'libx264',
        '-preset', 'medium',
        '-crf', '23',
        '-pix_fmt', 'yuv420p',
        'output.mp4'
      ]);

      console.log('Reading output video...');
      const data = await ffmpeg.readFile('output.mp4') as Uint8Array;
      // @ts-ignore - FFmpeg Uint8Array type compatibility
      const videoBlob = new Blob([data], { type: 'video/mp4' });

      // Download the video
      const url = URL.createObjectURL(videoBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cesium-route-${Date.now()}.mp4`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      // Cleanup FFmpeg files
      for (let i = 0; i < totalFrames; i++) {
        const filename = `frame-${String(i).padStart(6, '0')}.jpg`;
        try {
          await ffmpeg.deleteFile(filename);
        } catch (e) {
          // Ignore cleanup errors
        }
      }
      try {
        await ffmpeg.deleteFile('output.mp4');
      } catch (e) {
        // Ignore
      }

      setIsEncoding(false);
      setEncodingProgress('');
      console.log('Video encoding complete!');
      alert(`Video created successfully!\n${totalFrames} frames @ ${fps} FPS`);
    } catch (error) {
      console.error('Failed to encode video:', error);
      setIsEncoding(false);
      setEncodingProgress('');
      alert('Failed to encode video. Check console for details.');
    }
  };

  if (!viewer) return null;

  // Check if in Docker mode (don't show button)
  const isDocker = window.location.search.includes('docker=true');
  if (isDocker) return null;

  return (
    <div style={{
      position: 'absolute',
      top: '10px',
      left: '50%',
      transform: 'translateX(-50%)',
      zIndex: 1000
    }}>
      {isEncoding ? (
        <button
          disabled
          style={{
            padding: '12px 20px',
            backgroundColor: '#666',
            color: 'white',
            border: 'none',
            borderRadius: '8px',
            fontSize: '14px',
            fontWeight: 'bold',
            cursor: 'not-allowed',
            boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '4px'
          }}
        >
          <div>ðŸŽ¬ Encoding Video...</div>
          {encodingProgress && (
            <div style={{ fontSize: '11px', opacity: 0.8 }}>
              {encodingProgress}
            </div>
          )}
        </button>
      ) : !isRecording ? (
        <button
          onClick={startRecording}
          disabled={isPreparing || isLoadingFFmpeg}
          style={{
            padding: '12px 20px',
            backgroundColor: (isPreparing || isLoadingFFmpeg) ? '#666' : '#ff4444',
            color: 'white',
            border: 'none',
            borderRadius: '8px',
            fontSize: '14px',
            fontWeight: 'bold',
            cursor: (isPreparing || isLoadingFFmpeg) ? 'not-allowed' : 'pointer',
            boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '4px'
          }}
        >
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <span style={{
              width: '12px',
              height: '12px',
              backgroundColor: 'white',
              borderRadius: '50%',
              display: 'inline-block'
            }} />
            {isLoadingFFmpeg ? 'Loading FFmpeg...' : isPreparing ? 'Preparing...' : 'Start Recording'}
          </div>
          {!isLoadingFFmpeg && estimatedSeconds && (
            <span style={{ fontSize: '11px', opacity: 0.8 }}>
              ~{estimatedSeconds}s @ {animationSpeed}x speed
            </span>
          )}
        </button>
      ) : (
        <button
          onClick={stopRecording}
          style={{
            padding: '12px 20px',
            backgroundColor: '#444',
            color: 'white',
            border: '2px solid #ff4444',
            borderRadius: '8px',
            fontSize: '14px',
            fontWeight: 'bold',
            cursor: 'pointer',
            boxShadow: '0 2px 8px rgba(0,0,0,0.3)',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '4px',
            animation: 'pulse 1.5s ease-in-out infinite'
          }}
        >
          <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
            <span style={{
              width: '12px',
              height: '12px',
              backgroundColor: '#ff4444',
              borderRadius: '2px',
              display: 'inline-block'
            }} />
            Stop Recording
          </div>
          <span style={{ fontSize: '11px', opacity: 0.8 }}>
            {frameCount} frames
          </span>
        </button>
      )}
      <style>{`
        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.7; }
        }
      `}</style>
    </div>
  );
}
